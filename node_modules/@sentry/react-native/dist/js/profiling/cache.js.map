{"version":3,"file":"cache.js","sourceRoot":"","sources":["../../../src/js/profiling/cache.ts"],"names":[],"mappings":"AAEA,MAAM,CAAC,MAAM,aAAa,GAAG,aAAa,CAA6D,EAAE,CAAC,CAAC;AAE3G;;;GAGG;AACH,SAAS,aAAa,CACpB,IAAY;IAQZ,kGAAkG;IAClG,IAAI,aAAa,GAAU,EAAE,CAAC;IAC9B,IAAI,KAAK,GAA0B,EAAE,CAAC;IAEtC,OAAO;QACL,GAAG,CAAC,GAAQ,EAAE,KAAY;YACxB,OAAO,aAAa,CAAC,MAAM,IAAI,IAAI,EAAE;gBACnC,kEAAkE;gBAClE,iDAAiD;gBACjD,MAAM,cAAc,GAAG,aAAa,CAAC,KAAK,EAAE,CAAC;gBAE7C,IAAI,cAAc,KAAK,SAAS,EAAE;oBAChC,gEAAgE;oBAChE,OAAO,KAAK,CAAC,cAAc,CAAC,CAAC;iBAC9B;aACF;YAED,mDAAmD;YACnD,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE;gBACd,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;aAClB;YAED,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACxB,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACrB,CAAC;QACD,KAAK;YACH,KAAK,GAAG,EAAE,CAAC;YACX,aAAa,GAAG,EAAE,CAAC;QACrB,CAAC;QACD,GAAG,CAAC,GAAQ;YACV,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC;QACpB,CAAC;QACD,IAAI;YACF,OAAO,aAAa,CAAC,MAAM,CAAC;QAC9B,CAAC;QACD,mEAAmE;QACnE,MAAM,CAAC,GAAQ;YACb,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;gBACf,OAAO,KAAK,CAAC;aACd;YAED,gEAAgE;YAChE,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC;YAElB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC7C,IAAI,aAAa,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;oBAC5B,aAAa,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC3B,MAAM;iBACP;aACF;YAED,OAAO,IAAI,CAAC;QACd,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["import type { AndroidCombinedProfileEvent, CombinedProfileEvent } from './types';\n\nexport const PROFILE_QUEUE = makeFifoCache<string, CombinedProfileEvent | AndroidCombinedProfileEvent>(20);\n\n/**\n * Creates a cache that evicts keys in fifo order\n * @param size {Number}\n */\nfunction makeFifoCache<Key extends string, Value>(\n  size: number,\n): {\n  get: (key: Key) => Value | undefined;\n  add: (key: Key, value: Value) => void;\n  delete: (key: Key) => boolean;\n  clear: () => void;\n  size: () => number;\n} {\n  // Maintain a fifo queue of keys, we cannot rely on Object.keys as the browser may not support it.\n  let evictionOrder: Key[] = [];\n  let cache: Record<string, Value> = {};\n\n  return {\n    add(key: Key, value: Value) {\n      while (evictionOrder.length >= size) {\n        // shift is O(n) but this is small size and only happens if we are\n        // exceeding the cache size so it should be fine.\n        const evictCandidate = evictionOrder.shift();\n\n        if (evictCandidate !== undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete cache[evictCandidate];\n        }\n      }\n\n      // in case we have a collision, delete the old key.\n      if (cache[key]) {\n        this.delete(key);\n      }\n\n      evictionOrder.push(key);\n      cache[key] = value;\n    },\n    clear() {\n      cache = {};\n      evictionOrder = [];\n    },\n    get(key: Key): Value | undefined {\n      return cache[key];\n    },\n    size() {\n      return evictionOrder.length;\n    },\n    // Delete cache key and return true if it existed, false otherwise.\n    delete(key: Key): boolean {\n      if (!cache[key]) {\n        return false;\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete cache[key];\n\n      for (let i = 0; i < evictionOrder.length; i++) {\n        if (evictionOrder[i] === key) {\n          evictionOrder.splice(i, 1);\n          break;\n        }\n      }\n\n      return true;\n    },\n  };\n}\n"]}