{"version":3,"file":"AsyncExpiringMap.js","sourceRoot":"","sources":["../../../src/js/utils/AsyncExpiringMap.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * A Map that automatically removes entries after their TTL has expired.\n *\n * The map is Promise-aware, meaning it will start TTL countdown only after the promise has resolved.\n */\nexport class AsyncExpiringMap<K, V> {\n  private _ttl: number;\n  private _cleanupIntervalMs: number;\n  private _map: Map<K, { value: V | undefined; expiresAt: number | null; promise: PromiseLike<V> | null }>;\n  private _cleanupInterval: ReturnType<typeof setInterval>;\n\n  public constructor({\n    cleanupInterval = 5_000,\n    ttl = 2_000,\n  }: {\n    cleanupInterval?: number;\n    ttl?: number;\n  } = {}) {\n    this._ttl = ttl;\n    this._map = new Map();\n    this._cleanupIntervalMs = cleanupInterval;\n    this.startCleanup();\n  }\n\n  /**\n   * Set a key-value pair.\n   */\n  public set(key: K, promise: PromiseLike<V> | V): void {\n    if (!this._cleanupInterval) {\n      this.startCleanup();\n    }\n\n    if (typeof promise !== 'object' || !('then' in promise)) {\n      this._map.set(key, { value: promise, expiresAt: Date.now() + this._ttl, promise: null });\n      return;\n    }\n\n    const entry: { value: V | undefined; expiresAt: number | null; promise: PromiseLike<V> | null } = {\n      value: undefined,\n      expiresAt: null,\n      promise,\n    };\n    this._map.set(key, entry);\n\n    promise.then(\n      value => {\n        entry.value = value;\n        entry.expiresAt = Date.now() + this._ttl;\n        entry.promise = null;\n      },\n      () => {\n        entry.expiresAt = Date.now() + this._ttl;\n        entry.promise = null;\n      },\n    );\n  }\n\n  /**\n   * Pops a key-value pair.\n   */\n  public pop(key: K): PromiseLike<V> | V | undefined {\n    const entry = this.get(key);\n    this._map.delete(key);\n    return entry;\n  }\n\n  /**\n   * Get a value by key.\n   *\n   * If the values is expired it will be returned and removed from the map.\n   */\n  public get(key: K): PromiseLike<V> | V | undefined {\n    const entry = this._map.get(key);\n\n    if (!entry) {\n      return undefined;\n    }\n\n    if (entry.promise) {\n      return entry.promise;\n    }\n\n    if (entry.expiresAt && entry.expiresAt <= Date.now()) {\n      this._map.delete(key);\n    }\n\n    return entry.value;\n  }\n\n  /**\n   * Check if a key exists in the map.\n   *\n   * If the key is expired it's not present in the map.\n   */\n  public has(key: K): boolean {\n    const entry = this._map.get(key);\n\n    if (!entry) {\n      return false;\n    }\n\n    if (entry.promise) {\n      return true;\n    }\n\n    if (entry.expiresAt && entry.expiresAt <= Date.now()) {\n      this._map.delete(key);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Get the remaining time to live of a key.\n   */\n  public ttl(key: K): number | undefined {\n    const entry = this._map.get(key);\n    if (entry && entry.expiresAt) {\n      const remainingTime = entry.expiresAt - Date.now();\n      return remainingTime > 0 ? remainingTime : 0;\n    }\n    return undefined;\n  }\n\n  /**\n   * Remove expired entries.\n   */\n  public cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this._map.entries()) {\n      if (entry.expiresAt && entry.expiresAt <= now) {\n        this._map.delete(key);\n      }\n    }\n    const size = this._map.size;\n    if (!size) {\n      this.stopCleanup();\n    }\n  }\n\n  /**\n   * Clear all entries.\n   */\n  public clear(): void {\n    clearInterval(this._cleanupInterval);\n    this._map.clear();\n  }\n\n  /**\n   * Stop the cleanup interval.\n   */\n  public stopCleanup(): void {\n    clearInterval(this._cleanupInterval);\n  }\n\n  /**\n   * Start the cleanup interval.\n   */\n  public startCleanup(): void {\n    this._cleanupInterval = setInterval(() => this.cleanup(), this._cleanupIntervalMs);\n  }\n}\n"]}